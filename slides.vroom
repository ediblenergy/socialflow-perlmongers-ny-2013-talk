# This is a sample Vroom input file. It should help you get started.
#
# Edit this file with your content. Then run `vroom vroom` to start
# the show!
#
# See `perldoc Vroom` for complete details.
#
---- config
# Basic config options.
title: SocialFlow, from 20_000 feet!
indent: 5
auto_size: 1
# height: 18
# width: 69
vim_opts: '-u NONE'
colorscheme: jellybeans

# The following options are for Gvim usage.
# vim: gvim
# gvimrc: |
#   set fuopt=maxhorz,maxvert
#   set guioptions=egmLtT
#   set guifont=Bitstream_Vera_Sans_Mono:h18
#   set guicursor=a:blinkon0-ver25-Cursor
#   colorscheme default

---- 

SocialFlow - A brief rundown of our most interesting ( to me ) perl projects

* NY Perl Mongers ( http://www.meetup.com/The-New-York-Perl-Meetup-Group/ )

* July 18, 2013

---- skip
"If I have seen further it is by standing on the shoulders of giants."
- Isaac Newton

+ "Good artists copy; great artists steal"
- Steve Jobs, missatributing a quote to Pablo Picasso

----perl,i4

sub solve_for_business_request {
    my($self,$request) = @_;
    return $self->search_metacpan_for($request)
        || die "beats me";
}


====
Its hard to play down the role CPAN has played in the development of SocialFlow.

----
== Database

* DBIx::Class
* ZMQ
* Redis

----
== 3rd party 

* Net::Twitter
* Facebook::Graph
* Web::Scraper

----

== Web Development

* Catalyst
* Plack
* Starman

----

== Toolchain

* Dist::Zilla
* Devel::Local
* Object::Remote
* App::Nopaste
* App::GitGot
* Reply
* App::cpanminus

----

== Some cool stuff SocialFlow does

* Imitate perl Open Source standards
+* Internal CPAN
* A repo for every distro (with tests! ...
+ Sometimes!! )
----

== Some cool stuff SocialFlow does, with DBIx::Class

* Separate CPAN dists for (DBIx::Class::)Schemas
* Import::Into
* DBIx::Class::Candy

----perl
use strict;
use warnings;

package SocialFlow::Web::Schema::Result::Client;
use SocialFlow::Billing::ProductType qw[ :all ];
use parent 'SocialFlow::Web::Schema::Result';
__PACKAGE__->load_components(qw/TimeStamp +SocialFlow::Web::Schema::Component::Roles/);
__PACKAGE__->table('client');
__PACKAGE__->add_columns(
    client_id        => { data_type => 'serial', },
    client_source_id => { data_type => 'integer'  },
    company          => { data_type => 'citext', accessor => '_company' },    # case insensitive
    website_url      => { data_type => 'text', },
    access_tier      => { data_type => 'smallint', default_value => 0 },    # standard / business / enterprise (use sub tier - below)
    active           => { data_type => 'smallint' },    # active, deleted, ?
    opted_in         => { data_type => 'boolean', default_value => 'false' },
    create_date      => { data_type => 'timestamp', set_on_create => 1 },
    max_social_accts => { data_type => 'integer',  default_value => 0 },
    default_time_zone => { data_type => 'text', default_value => 'UTC' },
);

# recurrence
# 0 - Monthly
# 1 = Yearly

__PACKAGE__->set_primary_key("client_id");
__PACKAGE__->belongs_to(
    client_source => 'SocialFlow::Web::Schema::Result::ClientSource',
    'client_source_id'
);
__PACKAGE__->has_many(
    client_appusers => 'SocialFlow::Web::Schema::Result::ClientAppuser',
    'client_id'
);
__PACKAGE__->many_to_many(
    appusers => 'client_appusers',
    'appuser'
);
__PACKAGE__->has_many(
    client_appuser_roles =>
        'SocialFlow::Web::Schema::Result::ClientAppuserRole',
    'client_id'
);

__PACKAGE__->has_many(
    client_services => 'SocialFlow::Web::Schema::Result::ClientService',
    'client_id'
);

__PACKAGE__->has_many(
    appuser_client_services =>
        'SocialFlow::Web::Schema::Result::AppuserClientService',
    'client_id'
);
__PACKAGE__->has_many(
    content_queues => 'SocialFlow::Web::Schema::Result::ContentQueue',
    'client_id'
    );

__PACKAGE__->has_many(
    email_transactions =>
        'SocialFlow::Web::Schema::Result::EmailTransaction',
    'client_id'
);
__PACKAGE__->might_have(
    lead => 'SocialFlow::Web::Schema::Result::SalesforceClientLead',
    'client_id'
    );

__PACKAGE__->has_many(
    credit_cards => 'SocialFlow::Web::Schema::Result::ClientCreditCard',
    'client_id'
);

__PACKAGE__->might_have(
    billing_address => 'SocialFlow::Web::Schema::Result::BillingAddress',
    'client_id'
    );

__PACKAGE__->has_many(
    receipts => 'SocialFlow::Web::Schema::Result::Receipt',
    'client_id'
    );

__PACKAGE__->has_many(
    braintree_receipts => 'SocialFlow::Web::Schema::Result::BraintreeReceipt',
    'client_id'
    );

__PACKAGE__->has_many(
    opportunities => 'SocialFlow::Web::Schema::Result::SalesforceOpportunity',
    'client_id'
    );

__PACKAGE__->has_many(
    api_consumers =>
        'SocialFlow::Web::Schema::Result::APIConsumer',
        'client_id'
    );

__PACKAGE__->has_many(
    feed_sources => 'SocialFlow::Web::Schema::Result::FeedSource', 'client_id'
);

__PACKAGE__->has_many(
    google_transactions => 'SocialFlow::Web::Schema::Result::GoogleCheckoutTransaction',
    'client_id'
    );

__PACKAGE__->has_many(
    braintree_transactions => 'SocialFlow::Web::Schema::Result::BraintreeTransaction',
    'client_id'
    );

__PACKAGE__->has_many(
    google_checkout_orders => 'SocialFlow::Web::Schema::Result::GoogleCheckoutOrder',
    'client_id'
    );

__PACKAGE__->has_many(
    braintree_orders => 'SocialFlow::Web::Schema::Result::BraintreeOrder',
    'client_id',
    );

__PACKAGE__->has_many(
    groups => "SocialFlow::Web::Schema::Result::ClientGroup", 'client_id'
);

__PACKAGE__->has_many(
    client_service_groups => 'SocialFlow::Web::Schema::Result::ClientServiceGroup', 'client_id'
);

__PACKAGE__->has_many(
    client_group_appusers => 'SocialFlow::Web::Schema::Result::ClientGroupAppuser', 'client_id'
);
__PACKAGE__->has_many(
    client_config_parameters =>
        'SocialFlow::Web::Schema::Result::ClientConfigParameter',
    'client_id'
);
__PACKAGE__->many_to_many(
    config_parameters => 'client_config_parameters', 'config_parameter'
);

__PACKAGE__->has_many(
    content_sources => 'SocialFlow::Web::Schema::Result::ContentSource',
    'client_id'
);

__PACKAGE__->might_have(
    bitly_credential_client => 'SocialFlow::Web::Schema::Result::BitlyCredentialClient',
    'client_id'
    );

__PACKAGE__->has_many(
    bitly_credentials => 'SocialFlow::Web::Schema::Result::BitlyCredential',
    'client_id'
);

__PACKAGE__->might_have(
    googl_credential_client => 'SocialFlow::Web::Schema::Result::GooglCredentialClient',
    'client_id'
    );

__PACKAGE__->has_many(
    googl_credentials => 'SocialFlow::Web::Schema::Result::GooglCredential',
    'client_id'
);
__PACKAGE__->might_have(
    trial_period => 'SocialFlow::Web::Schema::Result::ClientTrialPeriod',
    'client_id'
);

__PACKAGE__->has_many(
    promo_codes => 'SocialFlow::Web::Schema::Result::ClientPromoCode',
    'client_id'
);

__PACKAGE__->has_many(
    report_links => 'SocialFlow::Web::Schema::Result::ReportLink',
    'client_id'
);

__PACKAGE__->might_have(
    tribal_client => 'SocialFlow::Web::Schema::Result::TribalClient',
    'client_id'
);

__PACKAGE__->has_many(
    tribal_client_services => 'SocialFlow::Web::Schema::Result::TribalClientService',
    'client_id'
);

__PACKAGE__->has_many(
    client_socialflow_products => 
    'SocialFlow::Web::Schema::Result::ClientSocialFlowProduct',
    'client_id'
);

__PACKAGE__->has_many(
    client_performance_reports =>
    'SocialFlow::Web::Schema::Result::ClientPerformanceReport',
    'client_id'
);

__PACKAGE__->has_many(
    attention_accounts => 'SocialFlow::Web::Schema::Result::AttentionAccount', 'client_id'
);

__PACKAGE__->has_many(
    billing_subscriptions => 'SocialFlow::Web::Schema::Result::BillingSubscription',
    'client_id'
);
sub Active {
    return +{
        0 => 'lead',
        1 => 'active',
        2 => 'canceled',
        3 => 'suspended',
        4 => 'opt-in expired',
    };
}

sub status {
    my $self = shift;
    return Active->{$self->active};
}

=method monthly_order

Can only have 1 monthly order at any given time.

=cut
sub monthly_order {
    my ($self) = @_;

    # look for braintree orders
    my @orders = $self->braintree_orders->search(
        { is_monthly =>'true',
          status => { -not_in  => ['canceled', 'not_yet_invoiced'] } });
    foreach (@orders) {
        next if ($_->socialflow_product->is_trial);
        return $_;
    }
    
    # if none found look for google checkout orders
    my $order = $self->google_checkout_orders->search(
        { 'is_monthly' =>'true',
          status => { -not_in  => ['canceled'] } })->single;
    return $order;
}

# deprecated
sub monthly_bt_accounts {
    my ($self) = @_;
    my $total = 0;
    my @orders = $self->braintree_orders->search(
        { is_monthly =>'true',
          status => { -not_in  => ['canceled', 'not_yet_invoiced'] } });
    
    foreach my $order (@orders) {
        next if ($order->socialflow_product->is_trial);
        $total += $order->number_accounts;
    }
    
    return $total;
}

# deprecated
sub yearly_bt_accounts {
    my ($self) = @_;
    my $total = 0;
    my @orders = $self->braintree_orders->search(
        { is_monthly => 'false',
          status => { -not_in  => ['canceled', 'not_yet_invoiced'] } });
    foreach my $order (@orders) {
        $total += $order->number_accounts;
    }

    return $total;
}

sub num_monthly_accounts {
    my ($self) = @_;
    my $total = 0;
    my @orders = $self->braintree_orders->search(
        { is_monthly =>'true',
          status => { -not_in  => ['canceled', 'not_yet_invoiced'] } });
    foreach my $order (@orders) {
        $total += $order->number_accounts;
    }
    @orders = $self->google_checkout_orders->search(
        { 'is_monthly' =>'true',
          status => { -not_in  => ['canceled'] } });

    foreach my $order (@orders) {
        next if ($order->socialflow_product->is_trial);
        $total += $order->num_accounts;
    }

    return $total;
}

sub num_yearly_accounts {
    my $self = shift;
    
    my $total = 0;
    my @orders = $self->braintree_orders->search(
        { is_monthly => 'false',
          status => { -not_in  => ['canceled', 'not_yet_invoiced'] } });
    foreach my $order (@orders) {
        $total += $order->number_accounts;
    }
    @orders = $self->google_checkout_orders->search(
        { 'is_monthly' => 'false',
          status => { -not_in  => ['canceled'] } });
    foreach my $order (@orders) {
        $total += $order->num_accounts;
    }
    
    return $total;
}


sub add_promo {
    my ($self, $promo) = @_;
    my $found = $self->promo_codes->find({ promo_code_id => $promo->promo_code_id });
    if (!$found) {
        $self->add_to_promo_codes({ promo_code_id => $promo->promo_code_id });
    }
}

sub mark_promo_used {
    my ($self, $promo) = @_;
    $promo->update({ num_used => $promo->num_used + 1});
}

sub most_recent_promo {
    my $self = shift;
    return $self->promo_codes->search(
        {}, 
        { order_by => { -desc => 'create_date' } })->first;
}

sub start_trial {
    my $self        = shift;
    warn "STARTING TRIAL\n";
    my $today       = DateTime->today;
    my $trial_start = $today->clone->add( days => 1 );    #tomorrow at midnight
    my $trial_end = $trial_start->clone->add( months => 1 );
    warn "END DATE: " . $trial_end->datetime;
    my $ret = $self->create_related( "trial_period",
        { start_date => $trial_start, end_date => $trial_end } );
    $self->discard_changes;
    $ret;
}

sub trial_has_ended {
    my $self         = shift;
    my $trial_period = $self->trial_period;
    return 0 unless $trial_period;
    my $now = DateTime->now->epoch;
    return $trial_period->end_date->epoch < $now;
}

sub is_in_trial {
    my $self         = shift;
    my $trial_period = $self->trial_period;
    return 0 unless $trial_period;
    my $now = DateTime->now->epoch;
    if (   $now > $trial_period->start_date->clone->subtract( days => 1 )->epoch
        && $now < $trial_period->end_date->epoch )
    {
        return 1;
    }
    return 0;
}

sub end_trial {
    my $self         = shift;
    my $trial_period = $self->trial_period;
    return unless $trial_period;
    return unless $trial_period->end_date;
    my $now = DateTime->now->epoch;
    if ($trial_period->end_date->epoch > $now) {
        $trial_period->update({end_date => DateTime->today});
    }
}

sub num_orders {
    my $self = shift;
    my @bt_orders = $self->braintree_orders->search({ status => { -not_in  => ['canceled', 'not_yet_invoiced'] }});
    my @gc_orders = $self->google_checkout_orders->search({ status => {-not_in => ['canceled', 'not_yet_invoiced'] }});
    my $num = @bt_orders + @gc_orders;
    return $num;
}

# deprecated
# find out the max # of social account this client can have
sub account_limit {
    my $self = shift;
    
    if ($self->access_tier < 2) {
        return $self->access_tier + 1 if !$self->opted_in;

        my $limit = 0;
        my @bt_orders = $self->braintree_orders->search({ status => { -not_in  => ['canceled', 'not_yet_invoiced'] }});
        foreach my $order (@bt_orders) {
            $limit += $order->number_accounts;
        }
        
        # TODO: fix this
        my @gc_orders = $self->google_checkout_orders->search({ status => {-not_in => ['canceled', 'not_yet_invoiced'] }});
        $limit += scalar(@gc_orders);
        return $limit;
        
    } else { #enterprise
        return $self->max_social_accts;
    }
}

sub accounts_left {
    my ($self) = @_;
    my $total_accounts = $self->client_services->active_publishing_accounts->valid;
    my $limit = $self->account_limit;
    warn "Changes reflected";
    my $left = $limit - $total_accounts;
    warn "Total [$total_accounts] Limit[$limit] Left[$left]"; 
    return $left;
}

sub tier {
    my $self = shift;
   
    if ( my $arg = shift ) { 
        my %map = ( standard => 0, business => 1, enterprise => 2 );
        $self->access_tier( $map{ lc $arg } );
    }

    my $index = $self->access_tier;
    my @arr = (qw/standard business enterprise/);
    return $arr[$index];
}

sub superadmin_appuser {
    my $self = shift;
    my $admin_appuser_role =
        $self->client_appuser_roles->search( { role_id => $self->SuperAdmin() },
        { rows => 1 } )->first;
    return unless $admin_appuser_role;
    return $admin_appuser_role->appuser;
}

sub billing_contact_appuser {
    my $self = shift;
    my $role =
        $self->client_appuser_roles->search( { 'name' => 'billing contact' },
        { 'prefetch' => 'role', 'rows' => 1 } )->single;
    return unless $role;
    return $role->appuser;

}

# can only have one at a time.
# all monthly orders should have the same anniversary
sub monthly_billing_anniversary {
    my $self = shift;
    my @bt_orders = $self->braintree_orders->search({ is_monthly => 1 });
    if (@bt_orders && @bt_orders > 0) {
        return $bt_orders[0]->anniversary_date->day;
    } else {
        my @gc_orders = $self->google_checkout_orders->search({ is_monthly => 1 });
        if (@gc_orders && @gc_orders > 0) {
            return $gc_orders[0]->anniversary_date->day;
        }
    }

    return undef;
}

# since company names are optional, wrap the accessor and return
# the name of the superadmin user if needed
sub company { 
    my $self = shift;

    return $self->_company( @_ ) if @_;

    my $comp = $self->_company;
    return $comp if defined $comp && $comp =~ m{\w};

    my $user = $self->superadmin_appuser;
    return '' unless $user;

    return $user->full_name;
}

sub default_card {
    my $self = shift;
    return unless $self->credit_cards;
    return $self->credit_cards->search({ is_default => 'true', is_active => 'true' })->single;
}

sub add_appuser {
    my ( $self, $appuser_hash ) = @_;
    my $schema  = $self->result_source->schema;
    my $guard   = $schema->txn_scope_guard;
    my $appuser = $self->add_to_appusers($appuser_hash);
    for ( $self->SuperAdmin(), $self->LeadContact(), $self->BillingContact() ) {
        my $rs = $self->client_appuser_roles;
        $rs->count( { role_id => $_ } )
            or $rs->create( { appuser_id => $appuser->id, role_id => $_ } );
    }
    $self->client_config_parameters->create( {
            config_parameter_id =>
                $schema->config_param_by_name->{"Client::receipt_recipients"}
                ->{config_parameter_id},
            value => $appuser->email
        } );

    $guard->commit;
    return $appuser;
}
1;

----perl

package SocialFlow::Web::Schema::Result::Client;
use SocialFlow::Web::Schema::ResultBase {
    extra_components => [
        qw[
          +SocialFlow::Web::Schema::Component::Roles
          ] ] };

table('client');

primary_column client_id => { data_type => serial };

integer_column 'client_source_id';

column company => { data_type => citext, accessor => '_company' };

text_column 'website_url';

column access_tier => { data_type => smallint, default_value => 0 };

# Rename the accessor since this is not a boolean as the column name would suggest.
column active => { data_type => smallint, accessor => '_active' };

boolean_column opted_in => { default_value => 0 };

timestamp_column create_date => { set_on_create => true };

integer_column max_social_accts => { default_value => 0 };

text_column default_time_zone => { default_value => 'UTC' };

# recurrence
# 0 - Monthly
# 1 = Yearly

belongs_to(
    client_source => '::ClientSource',
    'client_source_id'
);
has_many(
    client_appusers => '::ClientAppuser',
    'client_id'
);
many_to_many(
    appusers => 'client_appusers',
    'appuser'
);
has_many(
    client_appuser_roles =>
        '::ClientAppuserRole',
    'client_id'
);

has_many(
    client_services => '::ClientService',
    'client_id'
);

has_many(
    appuser_client_services =>
        '::AppuserClientService',
    'client_id'
);
has_many(
    content_queues => '::ContentQueue',
    'client_id'
    );

has_many(
    email_transactions =>
        '::EmailTransaction',
    'client_id'
);
might_have(
    lead => '::SalesforceClientLead',
    'client_id'
    );

has_many(
    credit_cards => '::ClientCreditCard',
    'client_id'
);

might_have(
    billing_address => '::BillingAddress',
    'client_id'
    );

has_many(
    receipts => '::Receipt',
    'client_id'
    );

has_many(
    opportunities => '::SalesforceOpportunity',
    'client_id'
    );

has_many(
    api_consumers =>
        '::APIConsumer',
        'client_id'
    );

has_many(
    feed_sources => '::FeedSource', 'client_id'
);

has_many(
    braintree_orders => '::BraintreeOrder',
    'client_id',
    );

has_many(
    groups => "::ClientGroup", 'client_id'
);

has_many(
    client_service_groups => '::ClientServiceGroup', 'client_id'
);

has_many(
    client_group_appusers => '::ClientGroupAppuser', 'client_id'
);
has_many(
    client_config_parameters =>
        '::ClientConfigParameter',
    'client_id'
);
many_to_many(
    config_parameters => 'client_config_parameters', 'config_parameter'
);

has_many(
    content_sources => '::ContentSource',
    'client_id'
);

might_have(
    bitly_credential_client => '::BitlyCredentialClient',
    'client_id'
    );

has_many(
    bitly_credentials => '::BitlyCredential',
    'client_id'
);

might_have(
    googl_credential_client => '::GooglCredentialClient',
    'client_id'
    );

has_many(
    googl_credentials => '::GooglCredential',
    'client_id'
);
might_have(
    trial_period => '::ClientTrialPeriod',
    'client_id'
);

has_many(
    promo_codes => '::ClientPromoCode',
    'client_id'
);

has_many(
    report_links => '::ReportLink',
    'client_id'
);

might_have(
    tribal_client => '::TribalClient',
    'client_id'
);

has_many(
    tribal_client_services => '::TribalClientService',
    'client_id'
);

might_have(
    tribal_credential_client => '::TribalCredentialClient',
    'client_id'
);

has_many(
    tribal_credentials => '::TribalCredential',
    'client_id'
);

has_many(
    client_socialflow_products =>
    '::ClientSocialFlowProduct',
    'client_id'
);

has_many(
    client_performance_reports =>
    '::ClientPerformanceReport',
    'client_id'
);

has_many(
    attention_accounts => '::Attention::Account', 'client_id'
);

has_many(
    subscriptions => '::BTSubscription',
    'client_id'
);

has_many tracker_groups => '::TrackerGroup', 'client_id';

has_many rulesets => '::TrackerClientRuleSet', 'client_id';

might_have attention_client_budget => '::Attention::ClientBudget', 'client_id';

has_many attention_account_budgets => '::Attention::AccountBudget', 'client_id';

has_many
  attention_ad_campaign_set_budgets => '::Attention::AdCampaignSetBudget',
  'client_id';

has_many
  attention_ad_campaign_budgets => '::Attention::AdCampaignBudget',
  'client_id';

has_many
  attention_client_transactions => '::Attention::ClientTransaction',
  'client_id';

has_many command_centers => '::CommandCenter', 'client_id';

has_many client_labels => '::ClientLabel', 'client_id';

has_many client_socialflow_sites => '::ClientSocialFlowSite', 'client_id';

has_many socialflow_site => '::SocialFlowSite', 'site_id';

many_to_many socialflow_sites => 'client_socialflow_sites', 'socialflow_site';

sub Active {
    return +{
        0 => 'lead',
        1 => 'active',
        2 => 'canceled',
        3 => 'suspended',
        4 => 'opt-in expired',
    };
}

sub ActiveValues() {
    state $lookup = { reverse %{Active()} };
    $lookup;
}

sub status {
    my $self = shift;
    return Active->{$self->_active};
}

sub is_active {
    my ($self) = @_;
    $self->_active == ActiveValues->{'active'};
}

sub set_status {
    my ($self, $desired) = @_;

    my $codes = ActiveValues();

    exists $codes->{$desired} or croak "Unknown client status $desired";

    $self->_active($codes->{$desired});
}

sub social_accounts_left {
    my ($self) = @_;

    # 0 means unlimited. The easiest way to express this in perl is +Infinity.
    # Is this the best value to return? Makes sense for comparisons, but maybe
    # not if its displayed directly.
    return "Inf" if $self->max_social_accts == 0;

    my $total_accounts = $self->client_services->active_publishing_accounts->valid;
    my $limit = $self->max_social_accts;
    return $limit - $total_accounts;
}

sub tier {
    my $self = shift;

    if ( my $arg = shift ) {
        my %map = ( standard => 0, business => 1, enterprise => 2 );
        $self->access_tier( $map{ lc $arg } );
    }

    my $index = $self->access_tier;
    my @arr = (qw/standard business enterprise/);
    return $arr[$index];
}

sub superadmin_appuser {
    my $self = shift;
    my $admin_appuser_role =
        $self->client_appuser_roles->search( { role_id => $self->SuperAdmin() },
        { rows => 1 } )->first;
    return unless $admin_appuser_role;
    return $admin_appuser_role->appuser;
}

sub billing_contact_appuser {
    my $self = shift;
    my $role =
        $self->client_appuser_roles->search( { 'name' => 'billing contact' },
        { 'prefetch' => 'role', 'rows' => 1 } )->single;
    return unless $role;
    return $role->appuser;

}

# since company names are optional, wrap the accessor and return
# the name of the superadmin user if needed
sub company {
    my $self = shift;

    return $self->_company( @_ ) if @_;

    my $comp = $self->_company;
    return $comp if defined $comp && $comp =~ m{\w};

    my $user = $self->superadmin_appuser;
    return '' unless $user;

    return $user->full_name;
}

sub default_card {
    my $self = shift;
    return unless $self->credit_cards;
    return $self->credit_cards->search({ is_default => 'true', is_active => 'true' })->single;
}

sub add_appuser {
    my ( $self, $appuser_hash ) = @_;
    my $schema  = $self->result_source->schema;
    my $guard   = $schema->txn_scope_guard;
    my $appuser = $self->add_to_appusers($appuser_hash);
    for ( $self->SuperAdmin(), $self->LeadContact(), $self->BillingContact() ) {
        my $rs = $self->client_appuser_roles;
        $rs->count( { role_id => $_ } )
            or $rs->create( { appuser_id => $appuser->id, role_id => $_ } );
    }
    $self->client_config_parameters->create( {
            config_parameter_id =>
                $schema->config_param_by_name->{"Client::receipt_recipients"}
                ->{config_parameter_id},
            value => $appuser->email
        } );

    $guard->commit;
    return $appuser;
}

sub get_client_shortener {
    my $self = shift;
    return unless $self->tribal_credential_client;
    return $self->tribal_credential_client;
}

sub get_bitly_creds {
    my $self = shift;
    return unless $self->bitly_credential_client;
    return $self->bitly_credential_client;
}

sub get_googl_creds {
    my $self = shift;
    return unless $self->googl_credential_client;
    return $self->googl_credential_client;
}

1;


----perl
package SocialFlow::Schema::Util;
use strictures 1;
# ABSTRACT: Shared Schema column constants and utils

use DBIx::Class::Candy::Exports;
use JSON::XS;

my $json = JSON::XS->new;
sub json { $json }

use constant {
    text      => 'text',
    citext    => $ENV{CITEXT} || 'citext',
    serial    => ( $ENV{SERIAL} ) || 'serial',
    integer   => 'integer',
    bigint    => 'bigint',
    smallint  => 'smallint',
    inet      => 'inet',
    float     => 'float',
    timestamp => 'timestamp',
    date      => 'date',
    enum      => 'enum',
    bool  => 'boolean',    #namespace collision with boolean.pm
    true  => 1,
    false => 0,
};

sub _type_column {
    my($class,$type,$col,$params) = @_;
    $params ||= {};
    $class->add_column( $col => { data_type => $type, %$params } )
}

sub integer_column {
    shift->_type_column(integer,@_);
}

sub bigint_column {
    shift->_type_column(bigint,@_);
}

sub text_column {
    shift->_type_column(text,@_);
}

sub citext_column {
    shift->_type_column(citext,@_);
}

sub date_column {
    shift->_type_column(date,@_);
}

sub timestamp_column {
    shift->_type_column(timestamp,@_);
}

sub boolean_column {
    shift->_type_column(bool,@_);
}

sub bool_column {
    shift->boolean_column(@_);
}

sub float_column {
    shift->_type_column(float,@_);
}

sub create_date_column {
    shift->add_columns(
        create_date => { data_type => timestamp, set_on_create => 1, @_ } );
}

sub is_active_column {
    my($class,$default) = @_;
    $default //= 1;
    shift->add_columns(
        is_active => { data_type => bool, default_value => $default }
    );
}

sub update_date_column {
    shift->add_columns(
        update_date => {
            data_type     => timestamp,
            set_on_create => 1,
            set_on_update => 1,
            @_
        } );
}


export_methods(
    [
        qw(
          integer_column
          bigint_column
          text_column
          citext_column
          date_column
          timestamp_column
          float_column
          boolean_column
          create_date_column
          update_date_column
          is_active_column

          text
          citext
          timestamp
          date
          bool
          serial
          integer
          bigint
          smallint
          inet
          float
          enum


          true
          false
          )
    ]
);
1;

=head1 NAME

SocialFlow::Schema::Util - Shared functionality across all sf schemata

=head1 SYNOPSIS

    use DBIx::Class::Candy
        -components => [qw(
            +SocialFlow::Schema::Util
        )];

=head1 DESCRIPTION

=head1 AUTHOR

skaufman@socialflow.com

=head1 COPYRIGHT

Copyright (c) %s the %s L</AUTHOR> and L</CONTRIBUTORS>
as listed above.


----perl

package SocialFlow::Schema::ResultBase;
use strictures 1;
#use Devel::SimpleTrace;
use DBIx::Class::Candy ();
use Import::Into;
use SocialFlow::Schema::Util ();
#use boolean ();
use Carp ();
use Safe::Isa;
use Data::Dumper::Concise;
use List::Util qw(first);


sub _schema_specific_components {
    my $class = shift;
    ## This should be implemented by the child if any additional
    # components must be loaded by all result classes
    return ();
} 

sub _default_result_namespace {
    my $class = shift;
    ## Override if you want, reasonable default
    return sub () { $class->_schema_class . '::Result' };
}

sub _schema_class {
    die "_schema_class must be implemented by child class";
}

sub _candy_components {
    my($class,$params) = @_;
    my @imports = qw[
      TimeStamp
      +SocialFlow::Schema::Util
      Helper::Row::RelationshipDWIM
      Helper::Row::ProxyResultSetMethod
      ];
    push (@imports, $class->_schema_specific_components);
    if( $params->{extra_components} ) {
        push( @imports, @{ delete $params->{extra_components} } );
    }
    return \@imports;
}

sub import {
    my ( $class, $params ) = @_;
    my $target = caller;
    strictures->import::into($target,1);
    indirect->import::into($target);
    DBIx::Class::Candy->import::into( $target,
        -components => $class->_candy_components($params), );
    #boolean->import::into($target);
    Carp->import::into($target);
    Data::Dumper::Concise->import::into($target);
    Safe::Isa->import::into($target);
    {
        #For https://metacpan.org/module/DBIx::Class::Helper::Row::RelationshipDWIM
        no strict 'refs';
        no warnings 'once';
        *{"$target\::default_result_namespace"} = $class->_default_result_namespace;

        *{"$target\::sqlt_deploy_hook"} =
          _sqlt_deploy_hook( $class->_schema_class )
          unless *{"$target\::sqlt_deploy_hook"};
    }
}


# Installed into the source at import time
sub _sqlt_deploy_hook {
    my $schema_class = shift;
    return sub() {
        my ( $source, $sqlt_table ) = @_;

        # check for renamed constraints
        for my $rel ( $source->relationships ) {

            my $rel_info = $source->relationship_info($rel);

            next unless $rel_info->{attrs}{constraint_name};

            unless ( ref $source ) {
                $source = $schema_class->source($source);
            }

            # Work out the old constraint name
            my $relsource = $source->related_source($rel);
            my $idx;
            my %other_columns_idx =
              map { 'foreign.' . $_ => ++$idx } $relsource->columns;
            my @cond =
              sort { $other_columns_idx{$a} cmp $other_columns_idx{$b} }
              keys( %{ $rel_info->{cond} } );
            my @keys = map { $rel_info->{cond}->{$_} =~ /^\w+\.(\w+)$/ } @cond;

            my $old_name = join( '_', $source->name, 'fk', @keys );

            my ($c) = first {
                $_->type eq SQL::Translator::Schema::Constants::FOREIGN_KEY()
                  && $_->name eq $old_name;
            }
            $sqlt_table->get_constraints;

            $c->name( $rel_info->{attrs}{constraint_name} );
        }
    };
}

1;

=head1 NAME
Parent class that schema specific ::ResultBase classes are children of. Sets up DBIx candy and imports other useful modules into dbix result classes

----

== Algorithm::Dablooms

* "A Bloom filter, conceived by Burton Howard Bloom in 1970 is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not." -  http://en.wikipedia.org/wiki/Bloom_filter

*  Bitly Dablooms: "This project aims to demonstrate a novel bloom filter implementation that can scale, and provide not only the addition of new members, but reliable removal of existing members." - https://github.com/bitly/dablooms


----perl

my $id = 0;
my $bloom = Algorithm::Dablooms->new({
    capacity => 20_000,
    error_rate => 0.05,
    filename => $bloom_file,
});

#...

$bloom->add("Sam Kaufman", ++$id);

#later

$bloom->contains( $entity );

----

== Sam Kaufman

* twitter.com/edibleenergy
* github.com/ediblenergy
